; Replayer core to play packed-volume 43653Hz samples generated by pcmenc
; By Maxim in 2016-2018
;
; pcmenc should use the following command line arguments:
;
; pcmenc -rto 3 -p 4 -dt1 82 -dt2 82 -dt3 82 -smooth 10 file.wav
;
; and optionally -r to split sample into blocks for rom replayer

; There is one channel update per underlying sample.
; We emit one channel update every 82 cycles, to match an underlying sample at 43653Hz.

; The code is optimised for speed instead of space. It needs 
; its tables to be aligned to a multiple of 256 bytes.
; It spends 308 cycles waiting plus 184 cycles working to emit 6 "samples",
; so there is 63% of the CPU left for other work.
; This is in chunks of up to 64 cycles at a time, and the waiting code must 
; preserve hl, bc and de - so exx can free up registers at the cost of 8 cycles per chunk,
; leaving ~53% of the CPU.

;-------------------------------------
; Plays one sample
; HL - points to triplet count followed by data
;-------------------------------------

; Tables - these must be aligned to a multiple of 256 bytes
; Each table consists of 256 bytes which translate a given byte (two nibbles)
; to the PSG output value for either the high or low nibble, to each of the 
; three channels in turn.
srl4_table_0:
  .repeat 256 index n
  .db (0 << 5) | $90 | (n>>4)
  .endr
lo4_table_1:
  .repeat 256 index n
  .db (1 << 5) | $90 | (n & $f)
  .endr
srl4_table_2:
  .repeat 256 index n
  .db (2 << 5) | $90 | (n>>4)
  .endr
lo4_table_0:
  .repeat 256 index n
  .db (0 << 5) | $90 | (n & $f)
  .endr
srl4_table_1:
  .repeat 256 index n
  .db (1 << 5) | $90 | (n>>4)
  .endr
lo4_table_2:
  .repeat 256 index n
  .db (2 << 5) | $90 | (n & $f)
  .endr
  
.macro Delay args n
  .printt "Delay "
  .printv dec n
  .printt "\n"
  .if n == 64
  .repeat 16
  nop     ; 16*4
  .endr
  .else
  .if n == 43
  .repeat 9
  nop     ; 4*9
  .endr
  add a,0 ; 7
  .else
  .if n == 16
  .repeat 4
  nop
  .endr
  .else
  .printt "Unhandled delay "
  .printv dec n
  .printt "\n"
  .fail
  .endif
  .endif
  .endif
.endm

PLAY_SAMPLE:
  ; Load triplet count
  ld c, (hl)
  inc hl
  ld b, (hl)
  inc hl
  ; We divide it by 2. 
  ; This is a bit of a hack because it is a triplet count, not a sextuplet count, and we loop every 6 outputs.
  ; We could check in-loop but that would cost a bunch of cycles; this way saves that time at the cost of maybe missing the last sample,
  ; but then we have jitter every page anyway.
  ld a,b
  srl a
  ld b,a
  ld a,c
  rra
  ld c,a
  
PsgLoop:
  ; Start at the front of the tables
  ld d,>srl4_table_0  ; 7
  ; Get byte
  ld e,(hl)           ; 7
  inc hl              ; 6
  ; Emit
  ld a,(de)           ; 7
  inc d               ; 4
  out ($7f),a         ; 11    <- Nibble 1/6

  ; We maximise the size of this gap...
  Delay                 82-7-11 ; = 64

  ; Next nibble
  ld a,(de)           ; 7
  out ($7f),a         ; 11    <- Nibble 2/6
  
  Delay                 82-7-6-4-7-4-11 ; = 43
  ; Get byte
  ld e,(hl)           ; 7
  inc hl              ; 6
  ; Emit
  inc d               ; 4
  ld a,(de)           ; 7
  inc d               ; 4
  out ($7f),a         ; 11    <- Nibble 3/6
  
  ; Another big-as-possible gap
  Delay                 82-7-11 ; = 64
  ; Next nibble
  ld a,(de)           ; 7
  out ($7f),a         ; 11    <- Nibble 4/6
  
  Delay                 82-7-6-4-7-4-11 ; = 43
  ; Get byte
  ld e,(hl)           ; 7
  inc hl              ; 6
  ; Emit
  inc d               ; 4
  ld a,(de)           ; 7
  inc d               ; 4
  out ($7f),a         ; 11    <- Nibble 5/6
  
  ; Another big-as-possible gap
  Delay                 82-7-11 ; = 64
  ; Next nibble
  ld a,(de)           ; 7
  out ($7f),a         ; 11    <- Nibble 6/6
  
  ; Loop
  Delay                 82-6-4-4-10-7-7-6-7-4-11 ; = 16
  dec bc              ; 6
  ld a,b              ; 4
  or c                ; 4
  jp nz,PsgLoop       ; 10

  ret