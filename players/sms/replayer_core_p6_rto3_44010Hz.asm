;
; Replayer core to play vector encoded 44.1kHz samples generated by pcmenc
;
; pcmenc should use the following command line arguments:
;
; pcmenc -p 6 -rto 3 -dt1 81 -dt2 81 -dt3 82 file.wav
;
; and optionally -r <n> to split sample into n KB blocks
;

; There is one channel updates per underlying sample.
; We emit three channel updates, as evenly spaced as possible, looping
; every 244 cycles, to match an underlying sample at ~44010Hz
; (3579545 / 244 * 3 = 44010.8)

; We create some lookup tables for all the possible data values for both low and high nibbles.
; These must be 256-byte aligned and are ordered to match the outputs for a pair of triplets.
srl4_table_0:
  .repeat 256 index n
  .db (0 << 5) | $90 | (n>>4)
  .endr
lo4_table_1:
  .repeat 256 index n
  .db (1 << 5) | $90 | (n & $f)
  .endr
srl4_table_2:
  .repeat 256 index n
  .db (2 << 5) | $90 | (n>>4)
  .endr
lo4_table_0:
  .repeat 256 index n
  .db (0 << 5) | $90 | (n & $f)
  .endr
srl4_table_1:
  .repeat 256 index n
  .db (1 << 5) | $90 | (n>>4)
  .endr
lo4_table_2:
  .repeat 256 index n
  .db (2 << 5) | $90 | (n & $f)
  .endr

;-------------------------------------
; Plays one sample
; HL - points to data, must be aligned to 256 bytes
;-------------------------------------
PLAY_SAMPLE:
  ; hl points to the next sample index (source data)
  ; bc holds the sample count remaining to play
  ; hl' points to the vector tables
  ; de' points to the data -> PSG command lookup tables above
  ; b' is a copy of the initial value of h
  ; c' is a the high byte for the start of the PSG command tables
  
  ; save high bytes of hl and >srl4_table_0 to b' and c' (we require both are aligned to 256 bytes)
  ld a,h
  exx
    ld b,a
    ld c,>srl4_table_0
  exx
  
  ; move to start of data
  inc h
  inc h
  ; read counter
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  
; Could try to optimise this for space, but why bother as we have 1.5KB of tables :)
.macro Delay args n
  .if n == 4
  nop
  .else
  .if n == 48
  call Delay48
  .else
  .if n == 49
  call Delay49
  .else
  .if n == 59
  call Delay59
  .else
  .if n == 60
  call Delay60
  .else
  .printt "Unhandled Delay "
  .printv dec n
  .printt "\n"
  .fail
  .endif
  .endif
  .endif
  .endif
  .endif
.endm

; Our data is compressed in runs of 4 nibbles (2 bytes). 
; We need to emit in runs of 3 bytes (6 outputs), so we 
; need to unroll to 6 bytes to make it align:
;
; Get index
; Look up in vector table
; Emit high nibble for channel 0
; Emit low nibble for channel 1
; Next byte of vector
; Emit high nibble for channel 2
; Emit low nibble for channel 0
; Check count
; Get index
; Look up in vector table
; Emit high nibble for channel 1
; Emit low nibble for channel 2
; Next byte of vector
; Emit high nibble for channel 0
; Emit low nibble for channel 1
; Check count
; Get index
; Look up in vector table
; Emit high nibble for channel 2
; Emit low nibble for channel 0
; Next byte of vector
; Emit high nibble for channel 1
; Emit low nibble for channel 2
; Check count
; Loop

-:
                  ; 34 for loop
  ; Get index
  ld a,(hl)       ; 7
  exx             ; 4
    ; Look up in vector table
    ld l,a        ; 4
    ld h,b        ; 4
    ld e,(hl)     ; 7
    ; Emit high nibble for channel 0
    ld d,c        ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 82 cycles
    
    ; Emit low nibble for channel 1
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a   ; 11 -> 81

    ; Next byte of vector
    Delay           48
    inc h         ; 4
    ; Emit high nibble for channel 2
    inc d         ; 4
    ld e,(hl)     ; 7
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81

    ; Emit low nibble for channel 0
    Delay           60
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81

    ; Check count
    Delay           4
  exx             ; 4
  inc hl          ; 6
  dec bc          ; 6
  ld a,b          ; 4
  or c            ; 4
  ret z           ; 5
  ; Get index
  ld a,(hl)       ; 7
  exx             ; 4
    ; Look up in vector table
    ld l,a        ; 4
    ld h,b        ; 4
    ; Emit high nibble for channel 1
    inc d         ; 4
    ld e,(hl)     ; 7
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81 cycles
    
    ; Emit low nibble for channel 2
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a   ; 11 -> 81
    
    ; Next byte of vector
    Delay           49
    inc h         ; 4
    ld e,(hl)     ; 7
    ; Emit high nibble for channel 0
    ld d,c        ; 4
    ld a,(de)     ; 7
    out ($7f),a   ; 11 -> 82
    
    ; Emit low nibble for channel 1
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81
    
    ; Check count
    Delay           4
  exx             ; 4
  inc hl          ; 6
  dec bc          ; 6
  ld a,b          ; 4
  or c            ; 4
  ret z           ; 5
  ; Get index
  ld a,(hl)       ; 7
  exx             ; 4
    ; Look up in vector table
    ld l,a        ; 4
    ld h,b        ; 4
    ld e,(hl)     ; 7
    ; Emit high nibble for channel 2
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81 cycles

    ; Emit low nibble for channel 0
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a   ; 11 -> 82
    
    ; Next byte of vector
    Delay           48
    inc h         ; 4
    ld e,(hl)     ; 7
    ; Emit high nibble for channel 1
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a   ; 11 -> 81
    
    ; Emit low nibble for channel 2
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a   ; 11 -> 81
    
    ; Check count
  exx             ; 4
  inc hl          ; 6
  dec bc          ; 6
  ld a,b          ; 4
  or c            ; 4
  ; Loop
  jp nz,-         ; 10
  ret

; Delay helpers
Delay60:
  jr Delay48 ; 12
Delay59:
  jp Delay49 ; 10
Delay49:
  jp +    ; 10
Delay48:
  ld a,i  ; 9
+:jr +    ; 12
+:ret     ; 27 for call and ret
  
